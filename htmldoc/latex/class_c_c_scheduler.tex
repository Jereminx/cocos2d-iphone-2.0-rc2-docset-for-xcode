\hypertarget{class_c_c_scheduler}{\section{C\-C\-Scheduler Class Reference}
\label{class_c_c_scheduler}\index{C\-C\-Scheduler@{C\-C\-Scheduler}}
}
Inheritance diagram for C\-C\-Scheduler\-:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_c_scheduler}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_aea4340dae5ad2178a9362a4cb2d4c5bd}{update\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a5c8d8f28a0c5e59256de5795a4ed29ef}{schedule\-Selector\-:for\-Target\-:interval\-:repeat\-:delay\-:paused\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a58685c484a66f1f6f30a6720cc92ebd0}{schedule\-Selector\-:for\-Target\-:interval\-:paused\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a215c93c8d349ef0e05ccb5c4a3659d18}{schedule\-Update\-For\-Target\-:priority\-:paused\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_ad37c13d97a269598543ed3587fe23d8f}{schedule\-Block\-For\-Key\-:target\-:interval\-:repeat\-:delay\-:paused\-:block\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a714490ea280354963cd5dafb6cf5f02e}{unschedule\-Selector\-:for\-Target\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a6fb2a1e58e13f02ee13e6650c7a1e63c}{unschedule\-Block\-For\-Key\-:target\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_af9189c31ec6214811a144d330e75bd16}{unschedule\-Update\-For\-Target\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_ab57a6316afea5ccc4f674203b2119f3e}{unschedule\-All\-For\-Target\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a491d9b4f2b65668c82ec6b55726b39e6}{unschedule\-All}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a2ad1d8d118509a718a4aff0e1a82536b}{unschedule\-All\-With\-Min\-Priority\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a212ecf962efef408b95a2cffba8a0ba7}{pause\-Target\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a45bb79fed502ce7001c733b3355fb3e6}{resume\-Target\-:}
\item 
(B\-O\-O\-L) -\/ \hyperlink{class_c_c_scheduler_abbfddc0e81ebb2bee86281bb85aec1dd}{is\-Target\-Paused\-:}
\item 
(N\-S\-Set $\ast$) -\/ \hyperlink{class_c_c_scheduler_a2842338061b84d5fba4d3fcf1bd0e993}{pause\-All\-Targets}
\item 
(N\-S\-Set $\ast$) -\/ \hyperlink{class_c_c_scheduler_aba4caf0e71068c70928a9b33555cfb43}{pause\-All\-Targets\-With\-Min\-Priority\-:}
\item 
(void) -\/ \hyperlink{class_c_c_scheduler_a8f6a77d8b666d437120c54e7683a8afe}{resume\-Targets\-:}
\item 
\hypertarget{class_c_c_scheduler_a1ef27ee759deae171ee6ea14e351ecb1}{(void) -\/ {\bfseries D\-E\-P\-R\-E\-C\-A\-T\-E\-D\-\_\-\-A\-T\-T\-R\-I\-B\-U\-T\-E}}\label{class_c_c_scheduler_a1ef27ee759deae171ee6ea14e351ecb1}

\item 
\hypertarget{class_c_c_scheduler_a67547138cb359d0c40df1680a3da6048}{(void) -\/ {\bfseries schedule\-Selector\-:for\-Target\-:interval\-:paused\-:repeat\-:delay\-:}}\label{class_c_c_scheduler_a67547138cb359d0c40df1680a3da6048}

\item 
\hypertarget{class_c_c_scheduler_af4f426991590da0bec8c7d1e3ef175cd}{(void) -\/ {\bfseries unschedule\-All\-Selectors\-For\-Target\-:}}\label{class_c_c_scheduler_af4f426991590da0bec8c7d1e3ef175cd}

\item 
\hypertarget{class_c_c_scheduler_a2e3c5b8dbe1e568bc4570976e07e55a3}{(void) -\/ {\bfseries unschedule\-All\-Selectors\-With\-Min\-Priority\-:}}\label{class_c_c_scheduler_a2e3c5b8dbe1e568bc4570976e07e55a3}

\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_c_c_scheduler_a81e3a9622050656f2bc5e4ea524fd6f3}{(\hyperlink{class_c_c_scheduler}{C\-C\-Scheduler} $\ast$) + {\bfseries D\-E\-P\-R\-E\-C\-A\-T\-E\-D\-\_\-\-A\-T\-T\-R\-I\-B\-U\-T\-E}}\label{class_c_c_scheduler_a81e3a9622050656f2bc5e4ea524fd6f3}

\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{class_c_c_scheduler_a953795b5fc80b70df5c8ab870c040dd6}{\hyperlink{cc_types_8h_ae6c674aac4bfb46a4e6cb1e89bb66b4f}{cc\-Time} {\bfseries time\-Scale\-\_\-}}\label{class_c_c_scheduler_a953795b5fc80b70df5c8ab870c040dd6}

\item 
\hypertarget{class_c_c_scheduler_aee62ae1ef50145d937a38ba9c6af12fe}{struct \hyperlink{struct__list_entry}{\-\_\-list\-Entry} $\ast$ {\bfseries updates\-Neg}}\label{class_c_c_scheduler_aee62ae1ef50145d937a38ba9c6af12fe}

\item 
\hypertarget{class_c_c_scheduler_afa3a685478662b1b12f1d3455e773c29}{struct \hyperlink{struct__list_entry}{\-\_\-list\-Entry} $\ast$ {\bfseries updates0}}\label{class_c_c_scheduler_afa3a685478662b1b12f1d3455e773c29}

\item 
\hypertarget{class_c_c_scheduler_a83c99c999c564c860dc915954335588f}{struct \hyperlink{struct__list_entry}{\-\_\-list\-Entry} $\ast$ {\bfseries updates\-Pos}}\label{class_c_c_scheduler_a83c99c999c564c860dc915954335588f}

\item 
\hypertarget{class_c_c_scheduler_aa9f0c6e0ab470174f34832c02bed5cc4}{struct \hyperlink{struct__hash_update_entry}{\-\_\-hash\-Update\-Entry} $\ast$ {\bfseries hash\-For\-Updates}}\label{class_c_c_scheduler_aa9f0c6e0ab470174f34832c02bed5cc4}

\item 
\hypertarget{class_c_c_scheduler_a53138e145eb084c6d8a235e82fe7c7b0}{struct \hyperlink{struct__hash_selector_entry}{\-\_\-hash\-Selector\-Entry} $\ast$ {\bfseries hash\-For\-Timers}}\label{class_c_c_scheduler_a53138e145eb084c6d8a235e82fe7c7b0}

\item 
\hypertarget{class_c_c_scheduler_a4018b55f1f007c5414a738d22074dbf7}{struct \hyperlink{struct__hash_selector_entry}{\-\_\-hash\-Selector\-Entry} $\ast$ {\bfseries current\-Target}}\label{class_c_c_scheduler_a4018b55f1f007c5414a738d22074dbf7}

\item 
\hypertarget{class_c_c_scheduler_a75f829cd70a53bdd41622a646de677d0}{B\-O\-O\-L {\bfseries current\-Target\-Salvaged}}\label{class_c_c_scheduler_a75f829cd70a53bdd41622a646de677d0}

\item 
\hypertarget{class_c_c_scheduler_ae4c9b4d5a8aafeb87a46ce0fff93050f}{T\-I\-C\-K\-\_\-\-I\-M\-P {\bfseries imp\-Method}}\label{class_c_c_scheduler_ae4c9b4d5a8aafeb87a46ce0fff93050f}

\item 
\hypertarget{class_c_c_scheduler_ab8f6db555473427326631c00575893b0}{S\-E\-L {\bfseries update\-Selector}}\label{class_c_c_scheduler_ab8f6db555473427326631c00575893b0}

\item 
\hypertarget{class_c_c_scheduler_ac4af923773a663983e2f0c7394addf65}{B\-O\-O\-L {\bfseries update\-Hash\-Locked}}\label{class_c_c_scheduler_ac4af923773a663983e2f0c7394addf65}

\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
\hyperlink{cc_types_8h_ae6c674aac4bfb46a4e6cb1e89bb66b4f}{cc\-Time} \hyperlink{class_c_c_scheduler_ac406b41dafcecd9fd05786877114c98d}{time\-Scale}
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\hypertarget{class_c_c_scheduler_abbfddc0e81ebb2bee86281bb85aec1dd}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!is\-Target\-Paused\-:@{is\-Target\-Paused\-:}}
\index{is\-Target\-Paused\-:@{is\-Target\-Paused\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{is\-Target\-Paused\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (B\-O\-O\-L) {\bf is\-Target\-Paused\-:} 
\begin{DoxyParamCaption}
\item[{(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_abbfddc0e81ebb2bee86281bb85aec1dd}
Returns whether or not the target is paused \begin{DoxySince}{Since}
v1.\-0.\-0 
\end{DoxySince}

\begin{DoxyCode}
                      :(id)target
{
        NSAssert( target != nil, @"target must be non nil" );

        // Custom selectors
        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);
        if( element )
                return element->paused;
        
        // We should check update selectors if target does not have custom
       selectors
        tHashUpdateEntry * elementUpdate = NULL;
        HASH_FIND_INT(hashForUpdates, &target, elementUpdate);
        if ( elementUpdate )
                return elementUpdate->entry->paused;
        
        return NO;  // should never get here
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a2842338061b84d5fba4d3fcf1bd0e993}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!pause\-All\-Targets@{pause\-All\-Targets}}
\index{pause\-All\-Targets@{pause\-All\-Targets}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{pause\-All\-Targets}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (N\-S\-Set $\ast$) {\bf pause\-All\-Targets} 
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a2842338061b84d5fba4d3fcf1bd0e993}
Pause all selectors and blocks from all targets. You should N\-E\-V\-E\-R call this method, unless you know what you are doing. \begin{DoxySince}{Since}
v2.\-0.\-0 
\end{DoxySince}

\begin{DoxyCode}
{
        return [self pauseAllTargetsWithMinPriority:kCCPrioritySystem];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_aba4caf0e71068c70928a9b33555cfb43}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!pause\-All\-Targets\-With\-Min\-Priority\-:@{pause\-All\-Targets\-With\-Min\-Priority\-:}}
\index{pause\-All\-Targets\-With\-Min\-Priority\-:@{pause\-All\-Targets\-With\-Min\-Priority\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{pause\-All\-Targets\-With\-Min\-Priority\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (N\-S\-Set $\ast$) {\bf pause\-All\-Targets\-With\-Min\-Priority\-:} 
\begin{DoxyParamCaption}
\item[{(N\-S\-Integer)}]{min\-Priority}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_aba4caf0e71068c70928a9b33555cfb43}
Pause all selectors and blocks from all targets with a minimum priority. You should only call this with k\-C\-C\-Priority\-Non\-System\-Min or higher. \begin{DoxySince}{Since}
v2.\-0.\-0 
\end{DoxySince}


Referenced by pause\-All\-Targets.


\begin{DoxyCode}
                                        :(NSInteger)minPriority
{
        NSMutableSet* idsWithSelectors = [NSMutableSet setWithCapacity:50];

        // Custom Selectors
        for(tHashTimerEntry *element=hashForTimers; element != NULL; element=
      element->hh.next) {
                element->paused = YES;
                [idsWithSelectors addObject:element->target];
        }

        // Updates selectors
        tListEntry *entry, *tmp;
        if(minPriority < 0) {
                DL_FOREACH_SAFE( updatesNeg, entry, tmp ) {
                        if(entry->priority >= minPriority) {
                                entry->paused = YES;
                                [idsWithSelectors addObject:entry->target];
                        }
                }
        }
        if(minPriority <= 0) {
                DL_FOREACH_SAFE( updates0, entry, tmp ) {
                        entry->paused = YES;
                        [idsWithSelectors addObject:entry->target];
                }
        }
        DL_FOREACH_SAFE( updatesPos, entry, tmp ) {
                if(entry->priority >= minPriority) {
                        entry->paused = YES;
                        [idsWithSelectors addObject:entry->target];
                }
        }

        return idsWithSelectors;
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a212ecf962efef408b95a2cffba8a0ba7}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!pause\-Target\-:@{pause\-Target\-:}}
\index{pause\-Target\-:@{pause\-Target\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{pause\-Target\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf pause\-Target\-:} 
\begin{DoxyParamCaption}
\item[{(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a212ecf962efef408b95a2cffba8a0ba7}
Pauses the target. All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed. If the target is not present, nothing happens. \begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}


Referenced by C\-C\-Node\-::pause\-Scheduler\-And\-Actions.


\begin{DoxyCode}
                   :(id)target
{
        NSAssert( target != nil, @"target must be non nil" );

        // Custom selectors
        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);
        if( element )
                element->paused = YES;

        // Update selector
        tHashUpdateEntry * elementUpdate = NULL;
        HASH_FIND_INT(hashForUpdates, &target, elementUpdate);
        if( elementUpdate ) {
                NSAssert( elementUpdate->entry != NULL, @"pauseTarget: unknown
       error");
                elementUpdate->entry->paused = YES;
        }

}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a45bb79fed502ce7001c733b3355fb3e6}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!resume\-Target\-:@{resume\-Target\-:}}
\index{resume\-Target\-:@{resume\-Target\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{resume\-Target\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf resume\-Target\-:} 
\begin{DoxyParamCaption}
\item[{(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a45bb79fed502ce7001c733b3355fb3e6}
Resumes the target. The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again. If the target is not present, nothing happens. \begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}


Referenced by C\-C\-Node\-::resume\-Scheduler\-And\-Actions, and resume\-Targets\-:.


\begin{DoxyCode}
                    :(id)target
{
        NSAssert( target != nil, @"target must be non nil" );

        // Custom Selectors
        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);
        if( element )
                element->paused = NO;

        // Update selector
        tHashUpdateEntry * elementUpdate = NULL;
        HASH_FIND_INT(hashForUpdates, &target, elementUpdate);
        if( elementUpdate ) {
                NSAssert( elementUpdate->entry != NULL, @"resumeTarget: unknown
       error");
                elementUpdate->entry->paused = NO;
        }
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a8f6a77d8b666d437120c54e7683a8afe}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!resume\-Targets\-:@{resume\-Targets\-:}}
\index{resume\-Targets\-:@{resume\-Targets\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{resume\-Targets\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf resume\-Targets\-:} 
\begin{DoxyParamCaption}
\item[{(N\-S\-Set $\ast$)}]{targets\-To\-Resume}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a8f6a77d8b666d437120c54e7683a8afe}
Resume selectors on a set of targets. This can be useful for undoing a call to pause\-All\-Selectors. \begin{DoxySince}{Since}
v2.\-0.\-0 
\end{DoxySince}

\begin{DoxyCode}
                     :(NSSet *)targetsToResume
{
    for(id target in targetsToResume) {
        [self resumeTarget:target];
    }
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_ad37c13d97a269598543ed3587fe23d8f}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!schedule\-Block\-For\-Key\-:target\-:interval\-:repeat\-:delay\-:paused\-:block\-:@{schedule\-Block\-For\-Key\-:target\-:interval\-:repeat\-:delay\-:paused\-:block\-:}}
\index{schedule\-Block\-For\-Key\-:target\-:interval\-:repeat\-:delay\-:paused\-:block\-:@{schedule\-Block\-For\-Key\-:target\-:interval\-:repeat\-:delay\-:paused\-:block\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{schedule\-Block\-For\-Key\-:target\-:interval\-:repeat\-:delay\-:paused\-:block\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) schedule\-Block\-For\-Key\-: 
\begin{DoxyParamCaption}
\item[{(N\-S\-String$\ast$)}]{key}
\item[{target:(id)}]{target}
\item[{interval:({\bf cc\-Time})}]{interval}
\item[{repeat:(uint)}]{repeat}
\item[{delay:({\bf cc\-Time})}]{delay}
\item[{paused:(B\-O\-O\-L)}]{paused}
\item[{block:({\bf cc\-Time} dt)}]{block}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_ad37c13d97a269598543ed3587fe23d8f}
The scheduled block will be called every 'interval' seconds. 'key' is a unique identifier of the block. Needed to unschedule the block or update its interval. 'target' is needed for all the method related to \char`\"{}target\char`\"{} like \char`\"{}pause\char`\"{} and \char`\"{}unschedule\char`\"{} If 'interval' is 0, it will be called every frame, but if so, it recommended to use 'schedule\-Update\-For\-Target\-:' instead. 'repeat' lets the action be repeated repeat + 1 times, use k\-C\-C\-Repeat\-Forever to let the action run continuously. 'delay' is the amount of time the action will wait before it'll start. If paused is Y\-E\-S, then it won't be called until it is resumed. If the block is already scheduled, then only the interval parameter will be updated without re-\/scheduling it again. \begin{DoxySince}{Since}
v2.\-1 
\end{DoxySince}

\begin{DoxyCode}
                           :(NSString*)key target:(id)owner interval:(ccTime)
      interval repeat:(uint)repeat delay:(ccTime)delay paused:(BOOL)paused block:(void(^
      )(ccTime dt))block
{
        NSAssert( block != nil, @"Argument block must be non-nil");
        NSAssert( owner != nil, @"Argument owner must be non-nil");
        
        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &owner, element);
        
        if( ! element ) {
                element = calloc( sizeof( *element ), 1 );
                element->target = [owner retain];
                HASH_ADD_INT( hashForTimers, target, element );
                
                // Is this the 1st element ? Then set the pause level to all
       the selectors of this target
                element->paused = paused;
                
        } else
                NSAssert( element->paused == paused, @"CCScheduler. Trying to
       schedule a block with a pause value different than the target");
        
        
        if( element->timers == nil )
                element->timers = ccArrayNew(10);
        else
        {
                for( unsigned int i=0; i< element->timers->num; i++ ) {
                        CCTimer *timer = element->timers->arr[i];
                        if( [timer isKindOfClass:[CCTimerBlock class]] && [key 
      isEqualToString:[(CCTimerBlock*)timer key] ] ) {
                                CCLOG(@"CCScheduler#scheduleBlock. Block
       already scheduled. Updating interval from: %.4f to %.4f", [timer interval], interval);
                                [timer setInterval: interval];
                                return;
                        }
                }
                ccArrayEnsureExtraCapacity(element->timers, 1);
        }
        
        CCTimerBlock *timer = [[CCTimerBlock alloc] initWithTarget:owner 
      interval:interval repeat:repeat delay:delay key:key block:block];
        ccArrayAppendObject(element->timers, timer);
        [timer release];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a58685c484a66f1f6f30a6720cc92ebd0}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!schedule\-Selector\-:for\-Target\-:interval\-:paused\-:@{schedule\-Selector\-:for\-Target\-:interval\-:paused\-:}}
\index{schedule\-Selector\-:for\-Target\-:interval\-:paused\-:@{schedule\-Selector\-:for\-Target\-:interval\-:paused\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{schedule\-Selector\-:for\-Target\-:interval\-:paused\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) schedule\-Selector\-: 
\begin{DoxyParamCaption}
\item[{(S\-E\-L)}]{selector}
\item[{forTarget:(id)}]{target}
\item[{interval:({\bf cc\-Time})}]{interval}
\item[{paused:(B\-O\-O\-L)}]{paused}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a58685c484a66f1f6f30a6720cc92ebd0}
calls schedule\-Selector with k\-C\-C\-Repeat\-Forever and a 0 delay 
\begin{DoxyCode}
                        :(SEL)selector forTarget:(id)target interval:(ccTime)
      interval paused:(BOOL)paused
{
        [self scheduleSelector:selector forTarget:target interval:interval 
      repeat:kCCRepeatForever delay:0.0f paused:paused];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a5c8d8f28a0c5e59256de5795a4ed29ef}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!schedule\-Selector\-:for\-Target\-:interval\-:repeat\-:delay\-:paused\-:@{schedule\-Selector\-:for\-Target\-:interval\-:repeat\-:delay\-:paused\-:}}
\index{schedule\-Selector\-:for\-Target\-:interval\-:repeat\-:delay\-:paused\-:@{schedule\-Selector\-:for\-Target\-:interval\-:repeat\-:delay\-:paused\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{schedule\-Selector\-:for\-Target\-:interval\-:repeat\-:delay\-:paused\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) schedule\-Selector\-: 
\begin{DoxyParamCaption}
\item[{(S\-E\-L)}]{selector}
\item[{forTarget:(id)}]{target}
\item[{interval:({\bf cc\-Time})}]{interval}
\item[{repeat:(uint)}]{repeat}
\item[{delay:({\bf cc\-Time})}]{delay}
\item[{paused:(B\-O\-O\-L)}]{paused}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a5c8d8f28a0c5e59256de5795a4ed29ef}
The scheduled method will be called every 'interval' seconds. If paused is Y\-E\-S, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it recommended to use 'schedule\-Update\-For\-Target\-:' instead. If the selector is already scheduled, then only the interval parameter will be updated without re-\/scheduling it again. repeat lets the action be repeated repeat + 1 times, use k\-C\-C\-Repeat\-Forever to let the action run continuously delay is the amount of time the action will wait before it'll start

\begin{DoxySince}{Since}
v0.\-99.\-3, repeat and delay added in v1.\-1 
\end{DoxySince}


Referenced by C\-C\-Node\-::schedule\-:interval\-:repeat\-:delay\-:, and schedule\-Selector\-:for\-Target\-:interval\-:paused\-:.


\begin{DoxyCode}
                        :(SEL)selector forTarget:(id)target interval:(ccTime)
      interval repeat:(uint)repeat delay:(ccTime)delay paused:(BOOL)paused 
{
        NSAssert( selector != nil, @"Argument selector must be non-nil");
        NSAssert( target != nil, @"Argument target must be non-nil");

        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);

        if( ! element ) {
                element = calloc( sizeof( *element ), 1 );
                element->target = [target retain];
                HASH_ADD_INT( hashForTimers, target, element );

                // Is this the 1st element ? Then set the pause level to all
       the selectors of this target
                element->paused = paused;

        } else
                NSAssert( element->paused == paused, @"CCScheduler. Trying to
       schedule a selector with a pause value different than the target");


        if( element->timers == nil )
                element->timers = ccArrayNew(10);
        else
        {
                for( unsigned int i=0; i< element->timers->num; i++ ) {
                        CCTimer *timer = element->timers->arr[i];
                        if( [timer isKindOfClass:[CCTimerTargetSelector class]]
       && selector == [(CCTimerTargetSelector*)timer selector] ) {
                                CCLOG(@"CCScheduler#scheduleSelector. Selector
       already scheduled. Updating interval from: %.4f to %.4f", [timer interval], 
      interval);
                                [timer setInterval: interval];
                                return;
                        }
                }
                ccArrayEnsureExtraCapacity(element->timers, 1);
        }

        CCTimerTargetSelector *timer = [[CCTimerTargetSelector alloc] 
      initWithTarget:target selector:selector interval:interval repeat:repeat delay:delay];
        ccArrayAppendObject(element->timers, timer);
        [timer release];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a215c93c8d349ef0e05ccb5c4a3659d18}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!schedule\-Update\-For\-Target\-:priority\-:paused\-:@{schedule\-Update\-For\-Target\-:priority\-:paused\-:}}
\index{schedule\-Update\-For\-Target\-:priority\-:paused\-:@{schedule\-Update\-For\-Target\-:priority\-:paused\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{schedule\-Update\-For\-Target\-:priority\-:paused\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) schedule\-Update\-For\-Target\-: 
\begin{DoxyParamCaption}
\item[{(id)}]{target}
\item[{priority:(N\-S\-Integer)}]{priority}
\item[{paused:(B\-O\-O\-L)}]{paused}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a215c93c8d349ef0e05ccb5c4a3659d18}
Schedules the 'update' selector for a given target with a given priority. The 'update' selector will be called every frame. The lower the priority, the earlier it is called. \begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}


Referenced by C\-C\-Node\-::schedule\-Update\-With\-Priority\-:.


\begin{DoxyCode}
                               :(id)target priority:(NSInteger)priority paused:
      (BOOL)paused
{
        tHashUpdateEntry * hashElement = NULL;
        HASH_FIND_INT(hashForUpdates, &target, hashElement);
    if(hashElement)
    {
#if COCOS2D_DEBUG >= 1
        NSAssert( hashElement->entry->markedForDeletion, @"CCScheduler: You
       can't re-schedule an 'update' selector'. Unschedule it first");
#endif
        // TODO : check if priority has changed!

        hashElement->entry->markedForDeletion = NO;
        return;
    }

        // most of the updates are going to be 0, that's way there
        // is an special list for updates with priority 0
        if( priority == 0 )
                [self appendIn:&updates0 target:target paused:paused];

        else if( priority < 0 )
                [self priorityIn:&updatesNeg target:target priority:priority 
      paused:paused];

        else // priority > 0
                [self priorityIn:&updatesPos target:target priority:priority 
      paused:paused];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a491d9b4f2b65668c82ec6b55726b39e6}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!unschedule\-All@{unschedule\-All}}
\index{unschedule\-All@{unschedule\-All}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{unschedule\-All}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf unschedule\-All} 
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a491d9b4f2b65668c82ec6b55726b39e6}
Unschedules all selectors and blocks from all targets. You should N\-E\-V\-E\-R call this method, unless you know what you are doing.

\begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}

\begin{DoxyCode}
{
    [self unscheduleAllWithMinPriority:kCCPrioritySystem];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_ab57a6316afea5ccc4f674203b2119f3e}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!unschedule\-All\-For\-Target\-:@{unschedule\-All\-For\-Target\-:}}
\index{unschedule\-All\-For\-Target\-:@{unschedule\-All\-For\-Target\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{unschedule\-All\-For\-Target\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf unschedule\-All\-For\-Target\-:} 
\begin{DoxyParamCaption}
\item[{(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_ab57a6316afea5ccc4f674203b2119f3e}
Unschedules all selectors and blocks for a given target. This also includes the \char`\"{}update\char`\"{} selector. \begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}


Referenced by C\-C\-Node\-::unschedule\-All\-Selectors, and unschedule\-All\-With\-Min\-Priority\-:.


\begin{DoxyCode}
                              :(id)target
{
        // explicit nil handling
        if( target == nil )
                return;

        // Custom Selectors
        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);

        if( element ) {
                if( ccArrayContainsObject(element->timers, element->
      currentTimer) && !element->currentTimerSalvaged ) {
                        [element->currentTimer retain];
                        element->currentTimerSalvaged = YES;
                }
                ccArrayRemoveAllObjects(element->timers);
                if( currentTarget == element )
                        currentTargetSalvaged = YES;
                else
                        [self removeHashElement:element];
        }

        // Update Selector
        [self unscheduleUpdateForTarget:target];
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a2ad1d8d118509a718a4aff0e1a82536b}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!unschedule\-All\-With\-Min\-Priority\-:@{unschedule\-All\-With\-Min\-Priority\-:}}
\index{unschedule\-All\-With\-Min\-Priority\-:@{unschedule\-All\-With\-Min\-Priority\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{unschedule\-All\-With\-Min\-Priority\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf unschedule\-All\-With\-Min\-Priority\-:} 
\begin{DoxyParamCaption}
\item[{(N\-S\-Integer)}]{min\-Priority}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a2ad1d8d118509a718a4aff0e1a82536b}
Unschedules all selectors and blocks from all targets with a minimum priority. You should only call this with k\-C\-C\-Priority\-Non\-System\-Min or higher. \begin{DoxySince}{Since}
v2.\-0.\-0 
\end{DoxySince}


Referenced by unschedule\-All.


\begin{DoxyCode}
                                    :(NSInteger)minPriority
{
        // Custom Selectors
        for(tHashTimerEntry *element=hashForTimers; element != NULL; ) {
                id target = element->target;
                element=element->hh.next;
                [self unscheduleAllForTarget:target];
        }

        // Updates selectors
        tListEntry *entry, *tmp;
    if(minPriority < 0) {
        DL_FOREACH_SAFE( updatesNeg, entry, tmp ) {
            if(entry->priority >= minPriority) {
                [self unscheduleUpdateForTarget:entry->target];
            }
        }
    }
    if(minPriority <= 0) {
        DL_FOREACH_SAFE( updates0, entry, tmp ) {
            [self unscheduleUpdateForTarget:entry->target];
        }
    }
        DL_FOREACH_SAFE( updatesPos, entry, tmp ) {
        if(entry->priority >= minPriority) {
            [self unscheduleUpdateForTarget:entry->target];
        }
        }

}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a6fb2a1e58e13f02ee13e6650c7a1e63c}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!unschedule\-Block\-For\-Key\-:target\-:@{unschedule\-Block\-For\-Key\-:target\-:}}
\index{unschedule\-Block\-For\-Key\-:target\-:@{unschedule\-Block\-For\-Key\-:target\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{unschedule\-Block\-For\-Key\-:target\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) unschedule\-Block\-For\-Key\-: 
\begin{DoxyParamCaption}
\item[{(N\-S\-String$\ast$)}]{key}
\item[{target:(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a6fb2a1e58e13f02ee13e6650c7a1e63c}
Unshedules a block for a given key / target pair. If you want to unschedule the \char`\"{}update\char`\"{}, use unscheudle\-Update\-For\-Target. \begin{DoxySince}{Since}
v2.\-1 
\end{DoxySince}

\begin{DoxyCode}
                             :(NSString*)key target:(id)target
{
        // explicity handle nil arguments when removing an object
        if( target==nil && key==NULL)
                return;

        NSAssert( target != nil, @"Target MUST not be nil");
        NSAssert( key != NULL, @"key MUST not be NULL");

        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);

        if( element ) {

                for( unsigned int i=0; i< element->timers->num; i++ ) {
                        CCTimer *timer = element->timers->arr[i];


                        if( [timer isKindOfClass:[CCTimerBlock class]] &&  [key
       isEqualToString: [(CCTimerBlock*)timer key]] ) {

                                if( timer == element->currentTimer && !element
      ->currentTimerSalvaged ) {
                                        [element->currentTimer retain];
                                        element->currentTimerSalvaged = YES;
                                }

                                ccArrayRemoveObjectAtIndex(element->timers, i )
      ;

                                // update timerIndex in case we are in tick:,
       looping over the actions
                                if( element->timerIndex >= i )
                                        element->timerIndex--;

                                if( element->timers->num == 0 ) {
                                        if( currentTarget == element )
                                                currentTargetSalvaged = YES;
                                        else
                                                [self removeHashElement: 
      element];
                                }
                                return;
                        }
                }
        }

        // Not Found
//      NSLog(@"CCScheduler#unscheduleSelector:forTarget: selector not found:
       %@", selString);
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_a714490ea280354963cd5dafb6cf5f02e}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!unschedule\-Selector\-:for\-Target\-:@{unschedule\-Selector\-:for\-Target\-:}}
\index{unschedule\-Selector\-:for\-Target\-:@{unschedule\-Selector\-:for\-Target\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{unschedule\-Selector\-:for\-Target\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) unschedule\-Selector\-: 
\begin{DoxyParamCaption}
\item[{(S\-E\-L)}]{selector}
\item[{forTarget:(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_a714490ea280354963cd5dafb6cf5f02e}
Unshedules a selector for a given target. If you want to unschedule the \char`\"{}update\char`\"{}, use unscheudle\-Update\-For\-Target. \begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}


Referenced by C\-C\-Node\-::unschedule\-:.


\begin{DoxyCode}
                          :(SEL)selector forTarget:(id)target
{
        // explicity handle nil arguments when removing an object
        if( target==nil && selector==NULL)
                return;
        
        NSAssert( target != nil, @"Target MUST not be nil");
        NSAssert( selector != NULL, @"Selector MUST not be NULL");
        
        tHashTimerEntry *element = NULL;
        HASH_FIND_INT(hashForTimers, &target, element);
        
        if( element ) {
                
                for( unsigned int i=0; i< element->timers->num; i++ ) {
                        CCTimer *timer = element->timers->arr[i];
                        
                        
                        if( [timer isKindOfClass:[CCTimerTargetSelector class]]
       && selector == [(CCTimerTargetSelector*)timer selector] ) {
                                
                                if( timer == element->currentTimer && !element
      ->currentTimerSalvaged ) {
                                        [element->currentTimer retain];
                                        element->currentTimerSalvaged = YES;
                                }
                                
                                ccArrayRemoveObjectAtIndex(element->timers, i )
      ;
                                
                                // update timerIndex in case we are in tick:,
       looping over the actions
                                if( element->timerIndex >= i )
                                        element->timerIndex--;
                                
                                if( element->timers->num == 0 ) {
                                        if( currentTarget == element )
                                                currentTargetSalvaged = YES;
                                        else
                                                [self removeHashElement: 
      element];
                                }
                                return;
                        }
                }
        }
        
        // Not Found
        //      NSLog(@"CCScheduler#unscheduleSelector:forTarget: selector not
       found: %@", selString);
        
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_af9189c31ec6214811a144d330e75bd16}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!unschedule\-Update\-For\-Target\-:@{unschedule\-Update\-For\-Target\-:}}
\index{unschedule\-Update\-For\-Target\-:@{unschedule\-Update\-For\-Target\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{unschedule\-Update\-For\-Target\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf unschedule\-Update\-For\-Target\-:} 
\begin{DoxyParamCaption}
\item[{(id)}]{target}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_af9189c31ec6214811a144d330e75bd16}
Unschedules the update selector for a given target \begin{DoxySince}{Since}
v0.\-99.\-3 
\end{DoxySince}


Referenced by unschedule\-All\-For\-Target\-:, and unschedule\-All\-With\-Min\-Priority\-:.


\begin{DoxyCode}
                                 :(id)target
{
        if( target == nil )
                return;

        tHashUpdateEntry * element = NULL;
        HASH_FIND_INT(hashForUpdates, &target, element);
        if( element ) {
        if(updateHashLocked)
            element->entry->markedForDeletion = YES;
        else
            [self removeUpdateFromHash:element->entry];

//              // list entry
//              DL_DELETE( *element->list, element->entry );
//              free( element->entry );
//
//              // hash entry
//              [element->target release];
//              HASH_DEL( hashForUpdates, element);
//              free(element);
        }
}
\end{DoxyCode}
\hypertarget{class_c_c_scheduler_aea4340dae5ad2178a9362a4cb2d4c5bd}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!update\-:@{update\-:}}
\index{update\-:@{update\-:}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{update\-:}]{\setlength{\rightskip}{0pt plus 5cm}-\/ (void) {\bf update\-:} 
\begin{DoxyParamCaption}
\item[{({\bf cc\-Time})}]{dt}
\end{DoxyParamCaption}
}}\label{class_c_c_scheduler_aea4340dae5ad2178a9362a4cb2d4c5bd}
'update' the scheduler. You should N\-E\-V\-E\-R call this method, unless you know what you are doing. 
\begin{DoxyCode}
              : (ccTime) dt
{
    updateHashLocked = YES;

        if( timeScale_ != 1.0f )
                dt *= timeScale_;

        // Iterate all over the Updates selectors
        tListEntry *entry, *tmp;

        // updates with priority < 0
        DL_FOREACH_SAFE( updatesNeg, entry, tmp ) {
                if( ! entry->paused && !entry->markedForDeletion )
                        entry->impMethod( entry->target, updateSelector, dt );
        }

        // updates with priority == 0
        DL_FOREACH_SAFE( updates0, entry, tmp ) {
                if( ! entry->paused && !entry->markedForDeletion )
        {
                        entry->impMethod( entry->target, updateSelector, dt );
        }
        }

        // updates with priority > 0
        DL_FOREACH_SAFE( updatesPos, entry, tmp ) {
                if( ! entry->paused  && !entry->markedForDeletion )
                        entry->impMethod( entry->target, updateSelector, dt );
        }

        // Iterate all over the custom selectors (CCTimers)
        for(tHashTimerEntry *elt=hashForTimers; elt != NULL; ) {

                currentTarget = elt;
                currentTargetSalvaged = NO;

                if( ! currentTarget->paused ) {

                        // The 'timers' ccArray may change while inside this
       loop.
                        for( elt->timerIndex = 0; elt->timerIndex < elt->timers
      ->num; elt->timerIndex++) {
                                elt->currentTimer = elt->timers->arr[elt->
      timerIndex];
                                elt->currentTimerSalvaged = NO;

                                impMethod( elt->currentTimer, updateSelector, 
      dt);

                                if( elt->currentTimerSalvaged ) {
                                        // The currentTimer told the remove
       itself. To prevent the timer from
                                        // accidentally deallocating itself
       before finishing its step, we retained
                                        // it. Now that step is done, it is
       safe to release it.
                                        [elt->currentTimer release];
                                }

                                elt->currentTimer = nil;
                        }
                }

                // elt, at this moment, is still valid
                // so it is safe to ask this here (issue #490)
                elt = elt->hh.next;

                // only delete currentTarget if no actions were scheduled
       during the cycle (issue #481)
                if( currentTargetSalvaged && currentTarget->timers->num == 0 )
                        [self removeHashElement:currentTarget];
        }

    // delete all updates that are morked for deletion
    // updates with priority < 0
        DL_FOREACH_SAFE( updatesNeg, entry, tmp ) {
                if(entry->markedForDeletion )
        {
            [self removeUpdateFromHash:entry];
        }
        }

        // updates with priority == 0
        DL_FOREACH_SAFE( updates0, entry, tmp ) {
                if(entry->markedForDeletion )
        {
            [self removeUpdateFromHash:entry];
        }
        }

        // updates with priority > 0
        DL_FOREACH_SAFE( updatesPos, entry, tmp ) {
                if(entry->markedForDeletion )
        {
            [self removeUpdateFromHash:entry];
        }
        }

    updateHashLocked = NO;
        currentTarget = nil;
}
\end{DoxyCode}


\subsection{Property Documentation}
\hypertarget{class_c_c_scheduler_ac406b41dafcecd9fd05786877114c98d}{\index{C\-C\-Scheduler@{C\-C\-Scheduler}!time\-Scale@{time\-Scale}}
\index{time\-Scale@{time\-Scale}!CCScheduler@{C\-C\-Scheduler}}
\subsubsection[{time\-Scale}]{\setlength{\rightskip}{0pt plus 5cm}-\/ ({\bf cc\-Time}) {\bf time\-Scale}\hspace{0.3cm}{\ttfamily  \mbox{[}read, write, assign\mbox{]}}}}\label{class_c_c_scheduler_ac406b41dafcecd9fd05786877114c98d}
Modifies the time of all scheduled callbacks. You can use this property to create a 'slow motion' or 'fast forward' effect. Default is 1.\-0. To create a 'slow motion' effect, use values below 1.\-0. To create a 'fast forward' effect, use values higher than 1.\-0. \begin{DoxySince}{Since}
v0.\-8 
\end{DoxySince}
\begin{DoxyWarning}{Warning}
It will affect E\-V\-E\-R\-Y scheduled selector / action. 
\end{DoxyWarning}


The documentation for this class was generated from the following files\-:\begin{DoxyCompactItemize}
\item 
/\-Bing/\-File/cocos2d/cocos2d-\/iphone/cocos2d-\/iphone-\/2.\-1-\/beta4/cocos2d/cc\-Deprecated.\-m\item 
/\-Bing/\-File/cocos2d/cocos2d-\/iphone/cocos2d-\/iphone-\/2.\-1-\/beta4/cocos2d/C\-C\-Scheduler.\-h\item 
/\-Bing/\-File/cocos2d/cocos2d-\/iphone/cocos2d-\/iphone-\/2.\-1-\/beta4/cocos2d/C\-C\-Scheduler.\-m\end{DoxyCompactItemize}
