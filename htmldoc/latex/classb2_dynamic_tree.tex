\hypertarget{classb2_dynamic_tree}{\section{b2\-Dynamic\-Tree Class Reference}
\label{classb2_dynamic_tree}\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}}
}


{\ttfamily \#include $<$b2\-Dynamic\-Tree.\-h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classb2_dynamic_tree_a8af64cf6a1566fa4c5b5c9683bd937d9}{\hyperlink{classb2_dynamic_tree_a8af64cf6a1566fa4c5b5c9683bd937d9}{b2\-Dynamic\-Tree} ()}\label{classb2_dynamic_tree_a8af64cf6a1566fa4c5b5c9683bd937d9}

\begin{DoxyCompactList}\small\item\em Constructing the tree initializes the node pool. \end{DoxyCompactList}\item 
\hypertarget{classb2_dynamic_tree_a9060565fc63b4dd87d9560775c076786}{\hyperlink{classb2_dynamic_tree_a9060565fc63b4dd87d9560775c076786}{$\sim$b2\-Dynamic\-Tree} ()}\label{classb2_dynamic_tree_a9060565fc63b4dd87d9560775c076786}

\begin{DoxyCompactList}\small\item\em Destroy the tree, freeing the node pool. \end{DoxyCompactList}\item 
\hypertarget{classb2_dynamic_tree_ae44676f12977dada46037da47fc7ffbf}{int32 \hyperlink{classb2_dynamic_tree_ae44676f12977dada46037da47fc7ffbf}{Create\-Proxy} (const \hyperlink{structb2_a_a_b_b}{b2\-A\-A\-B\-B} \&aabb, void $\ast$user\-Data)}\label{classb2_dynamic_tree_ae44676f12977dada46037da47fc7ffbf}

\begin{DoxyCompactList}\small\item\em Create a proxy. Provide a tight fitting A\-A\-B\-B and a user\-Data pointer. \end{DoxyCompactList}\item 
\hypertarget{classb2_dynamic_tree_a62aa451e7d7fe029818dd05f76ea9cdc}{void \hyperlink{classb2_dynamic_tree_a62aa451e7d7fe029818dd05f76ea9cdc}{Destroy\-Proxy} (int32 proxy\-Id)}\label{classb2_dynamic_tree_a62aa451e7d7fe029818dd05f76ea9cdc}

\begin{DoxyCompactList}\small\item\em Destroy a proxy. This asserts if the id is invalid. \end{DoxyCompactList}\item 
bool \hyperlink{classb2_dynamic_tree_a7748252811f3c575015931399cbe4daa}{Move\-Proxy} (int32 proxy\-Id, const \hyperlink{structb2_a_a_b_b}{b2\-A\-A\-B\-B} \&aabb1, const \hyperlink{structb2_vec2}{b2\-Vec2} \&displacement)
\item 
void $\ast$ \hyperlink{classb2_dynamic_tree_a44ab57dce3c42b0a5847a64e489a71ce}{Get\-User\-Data} (int32 proxy\-Id) const 
\item 
\hypertarget{classb2_dynamic_tree_adf4676b1c34a57b4451bcbeaebe65687}{const \hyperlink{structb2_a_a_b_b}{b2\-A\-A\-B\-B} \& \hyperlink{classb2_dynamic_tree_adf4676b1c34a57b4451bcbeaebe65687}{Get\-Fat\-A\-A\-B\-B} (int32 proxy\-Id) const }\label{classb2_dynamic_tree_adf4676b1c34a57b4451bcbeaebe65687}

\begin{DoxyCompactList}\small\item\em Get the fat A\-A\-B\-B for a proxy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classb2_dynamic_tree_adf70aee89b4692fc79d65b1f54308585}{Query} (T $\ast$callback, const \hyperlink{structb2_a_a_b_b}{b2\-A\-A\-B\-B} \&aabb) const 
\item 
{\footnotesize template$<$typename T $>$ }\\void \hyperlink{classb2_dynamic_tree_abd7a5c6a5bc109dbbdb0ec3aae039648}{Ray\-Cast} (T $\ast$callback, const \hyperlink{structb2_ray_cast_input}{b2\-Ray\-Cast\-Input} \&input) const 
\item 
\hypertarget{classb2_dynamic_tree_abfac96c615b08406cba3e53b39800f1c}{void \hyperlink{classb2_dynamic_tree_abfac96c615b08406cba3e53b39800f1c}{Validate} () const }\label{classb2_dynamic_tree_abfac96c615b08406cba3e53b39800f1c}

\begin{DoxyCompactList}\small\item\em Validate this tree. For testing. \end{DoxyCompactList}\item 
int32 \hyperlink{classb2_dynamic_tree_add7e09cdf279e7c0031da9dfd4cdf4db}{Get\-Height} () const 
\item 
int32 \hyperlink{classb2_dynamic_tree_ae02c45d1a68b42e59d170438ddbb7977}{Get\-Max\-Balance} () const 
\item 
\hypertarget{classb2_dynamic_tree_ad78282a720c451e032b43c34cba02f1a}{float32 \hyperlink{classb2_dynamic_tree_ad78282a720c451e032b43c34cba02f1a}{Get\-Area\-Ratio} () const }\label{classb2_dynamic_tree_ad78282a720c451e032b43c34cba02f1a}

\begin{DoxyCompactList}\small\item\em Get the ratio of the sum of the node areas to the root area. \end{DoxyCompactList}\item 
\hypertarget{classb2_dynamic_tree_abd146017cfec1cf5ea7b87331f30a3ff}{void \hyperlink{classb2_dynamic_tree_abd146017cfec1cf5ea7b87331f30a3ff}{Rebuild\-Bottom\-Up} ()}\label{classb2_dynamic_tree_abd146017cfec1cf5ea7b87331f30a3ff}

\begin{DoxyCompactList}\small\item\em Build an optimal tree. Very expensive. For testing. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A dynamic A\-A\-B\-B tree broad-\/phase, inspired by Nathanael Presson's bt\-Dbvt. A dynamic tree arranges data in a binary tree to accelerate queries such as volume queries and ray casts. Leafs are proxies with an A\-A\-B\-B. In the tree we expand the proxy A\-A\-B\-B by b2\-\_\-fat\-A\-A\-B\-B\-Factor so that the proxy A\-A\-B\-B is bigger than the client object. This allows the client object to move by small amounts without triggering a tree update.

Nodes are pooled and relocatable, so we use node indices rather than pointers. 

\subsection{Member Function Documentation}
\hypertarget{classb2_dynamic_tree_add7e09cdf279e7c0031da9dfd4cdf4db}{\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}!Get\-Height@{Get\-Height}}
\index{Get\-Height@{Get\-Height}!b2DynamicTree@{b2\-Dynamic\-Tree}}
\subsubsection[{Get\-Height}]{\setlength{\rightskip}{0pt plus 5cm}int32 {\bf b2\-Dynamic\-Tree\-::\-Get\-Height} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classb2_dynamic_tree_add7e09cdf279e7c0031da9dfd4cdf4db}
Compute the height of the binary tree in O(\-N) time. Should not be called often. 

Referenced by b2\-Broad\-Phase\-::\-Get\-Tree\-Height().


\begin{DoxyCode}
{
        if (m_root == b2_nullNode)
        {
                return 0;
        }

        return m_nodes[m_root].height;
}
\end{DoxyCode}
\hypertarget{classb2_dynamic_tree_ae02c45d1a68b42e59d170438ddbb7977}{\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}!Get\-Max\-Balance@{Get\-Max\-Balance}}
\index{Get\-Max\-Balance@{Get\-Max\-Balance}!b2DynamicTree@{b2\-Dynamic\-Tree}}
\subsubsection[{Get\-Max\-Balance}]{\setlength{\rightskip}{0pt plus 5cm}int32 {\bf b2\-Dynamic\-Tree\-::\-Get\-Max\-Balance} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classb2_dynamic_tree_ae02c45d1a68b42e59d170438ddbb7977}
Get the maximum balance of an node in the tree. The balance is the difference in height of the two children of a node. 

Referenced by b2\-Broad\-Phase\-::\-Get\-Tree\-Balance().


\begin{DoxyCode}
{
        int32 maxBalance = 0;
        for (int32 i = 0; i < m_nodeCapacity; ++i)
        {
                const b2TreeNode* node = m_nodes + i;
                if (node->height <= 1)
                {
                        continue;
                }

                b2Assert(node->IsLeaf() == false);

                int32 child1 = node->child1;
                int32 child2 = node->child2;
                int32 balance = b2Abs(m_nodes[child2].height - m_nodes[child1].
      height);
                maxBalance = b2Max(maxBalance, balance);
        }

        return maxBalance;
}
\end{DoxyCode}
\hypertarget{classb2_dynamic_tree_a44ab57dce3c42b0a5847a64e489a71ce}{\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}!Get\-User\-Data@{Get\-User\-Data}}
\index{Get\-User\-Data@{Get\-User\-Data}!b2DynamicTree@{b2\-Dynamic\-Tree}}
\subsubsection[{Get\-User\-Data}]{\setlength{\rightskip}{0pt plus 5cm}void $\ast$ {\bf b2\-Dynamic\-Tree\-::\-Get\-User\-Data} (
\begin{DoxyParamCaption}
\item[{int32}]{proxy\-Id}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classb2_dynamic_tree_a44ab57dce3c42b0a5847a64e489a71ce}
Get proxy user data. \begin{DoxyReturn}{Returns}
the proxy user data or 0 if the id is invalid. 
\end{DoxyReturn}


Referenced by b2\-Broad\-Phase\-::\-Get\-User\-Data(), and b2\-Broad\-Phase\-::\-Update\-Pairs().


\begin{DoxyCode}
{
        b2Assert(0 <= proxyId && proxyId < m_nodeCapacity);
        return m_nodes[proxyId].userData;
}
\end{DoxyCode}
\hypertarget{classb2_dynamic_tree_a7748252811f3c575015931399cbe4daa}{\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}!Move\-Proxy@{Move\-Proxy}}
\index{Move\-Proxy@{Move\-Proxy}!b2DynamicTree@{b2\-Dynamic\-Tree}}
\subsubsection[{Move\-Proxy}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf b2\-Dynamic\-Tree\-::\-Move\-Proxy} (
\begin{DoxyParamCaption}
\item[{int32}]{proxy\-Id, }
\item[{const {\bf b2\-A\-A\-B\-B} \&}]{aabb1, }
\item[{const {\bf b2\-Vec2} \&}]{displacement}
\end{DoxyParamCaption}
)}}\label{classb2_dynamic_tree_a7748252811f3c575015931399cbe4daa}
Move a proxy with a swepted A\-A\-B\-B. If the proxy has moved outside of its fattened A\-A\-B\-B, then the proxy is removed from the tree and re-\/inserted. Otherwise the function returns immediately. \begin{DoxyReturn}{Returns}
true if the proxy was re-\/inserted. 
\end{DoxyReturn}

\begin{DoxyCode}
{
        b2Assert(0 <= proxyId && proxyId < m_nodeCapacity);

        b2Assert(m_nodes[proxyId].IsLeaf());

        if (m_nodes[proxyId].aabb.Contains(aabb))
        {
                return false;
        }

        RemoveLeaf(proxyId);

        // Extend AABB.
        b2AABB b = aabb;
        b2Vec2 r(b2_aabbExtension, b2_aabbExtension);
        b.lowerBound = b.lowerBound - r;
        b.upperBound = b.upperBound + r;

        // Predict AABB displacement.
        b2Vec2 d = b2_aabbMultiplier * displacement;

        if (d.x < 0.0f)
        {
                b.lowerBound.x += d.x;
        }
        else
        {
                b.upperBound.x += d.x;
        }

        if (d.y < 0.0f)
        {
                b.lowerBound.y += d.y;
        }
        else
        {
                b.upperBound.y += d.y;
        }

        m_nodes[proxyId].aabb = b;

        InsertLeaf(proxyId);
        return true;
}
\end{DoxyCode}
\hypertarget{classb2_dynamic_tree_adf70aee89b4692fc79d65b1f54308585}{\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}!Query@{Query}}
\index{Query@{Query}!b2DynamicTree@{b2\-Dynamic\-Tree}}
\subsubsection[{Query}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void {\bf b2\-Dynamic\-Tree\-::\-Query} (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{callback, }
\item[{const {\bf b2\-A\-A\-B\-B} \&}]{aabb}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classb2_dynamic_tree_adf70aee89b4692fc79d65b1f54308585}
Query an A\-A\-B\-B for overlapping proxies. The callback class is called for each proxy that overlaps the supplied A\-A\-B\-B. 

Referenced by b2\-Broad\-Phase\-::\-Query(), and b2\-Broad\-Phase\-::\-Update\-Pairs().


\begin{DoxyCode}
{
        b2GrowableStack<int32, 256> stack;
        stack.Push(m_root);

        while (stack.GetCount() > 0)
        {
                int32 nodeId = stack.Pop();
                if (nodeId == b2_nullNode)
                {
                        continue;
                }

                const b2TreeNode* node = m_nodes + nodeId;

                if (b2TestOverlap(node->aabb, aabb))
                {
                        if (node->IsLeaf())
                        {
                                bool proceed = callback->QueryCallback(nodeId);
                                if (proceed == false)
                                {
                                        return;
                                }
                        }
                        else
                        {
                                stack.Push(node->child1);
                                stack.Push(node->child2);
                        }
                }
        }
}
\end{DoxyCode}
\hypertarget{classb2_dynamic_tree_abd7a5c6a5bc109dbbdb0ec3aae039648}{\index{b2\-Dynamic\-Tree@{b2\-Dynamic\-Tree}!Ray\-Cast@{Ray\-Cast}}
\index{Ray\-Cast@{Ray\-Cast}!b2DynamicTree@{b2\-Dynamic\-Tree}}
\subsubsection[{Ray\-Cast}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void {\bf b2\-Dynamic\-Tree\-::\-Ray\-Cast} (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{callback, }
\item[{const {\bf b2\-Ray\-Cast\-Input} \&}]{input}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classb2_dynamic_tree_abd7a5c6a5bc109dbbdb0ec3aae039648}
Ray-\/cast against the proxies in the tree. This relies on the callback to perform a exact ray-\/cast in the case were the proxy contains a shape. The callback also performs the any collision filtering. This has performance roughly equal to k $\ast$ log(n), where k is the number of collisions and n is the number of proxies in the tree. 
\begin{DoxyParams}{Parameters}
{\em input} & the ray-\/cast input data. The ray extends from p1 to p1 + max\-Fraction $\ast$ (p2 -\/ p1). \\
\hline
{\em callback} & a callback class that is called for each proxy that is hit by the ray. \\
\hline
\end{DoxyParams}


Referenced by b2\-Broad\-Phase\-::\-Ray\-Cast().


\begin{DoxyCode}
{
        b2Vec2 p1 = input.p1;
        b2Vec2 p2 = input.p2;
        b2Vec2 r = p2 - p1;
        b2Assert(r.LengthSquared() > 0.0f);
        r.Normalize();

        // v is perpendicular to the segment.
        b2Vec2 v = b2Cross(1.0f, r);
        b2Vec2 abs_v = b2Abs(v);

        // Separating axis for segment (Gino, p80).
        // |dot(v, p1 - c)| > dot(|v|, h)

        float32 maxFraction = input.maxFraction;

        // Build a bounding box for the segment.
        b2AABB segmentAABB;
        {
                b2Vec2 t = p1 + maxFraction * (p2 - p1);
                segmentAABB.lowerBound = b2Min(p1, t);
                segmentAABB.upperBound = b2Max(p1, t);
        }

        b2GrowableStack<int32, 256> stack;
        stack.Push(m_root);

        while (stack.GetCount() > 0)
        {
                int32 nodeId = stack.Pop();
                if (nodeId == b2_nullNode)
                {
                        continue;
                }

                const b2TreeNode* node = m_nodes + nodeId;

                if (b2TestOverlap(node->aabb, segmentAABB) == false)
                {
                        continue;
                }

                // Separating axis for segment (Gino, p80).
                // |dot(v, p1 - c)| > dot(|v|, h)
                b2Vec2 c = node->aabb.GetCenter();
                b2Vec2 h = node->aabb.GetExtents();
                float32 separation = b2Abs(b2Dot(v, p1 - c)) - b2Dot(abs_v, h);
                if (separation > 0.0f)
                {
                        continue;
                }

                if (node->IsLeaf())
                {
                        b2RayCastInput subInput;
                        subInput.p1 = input.p1;
                        subInput.p2 = input.p2;
                        subInput.maxFraction = maxFraction;

                        float32 value = callback->RayCastCallback(subInput, 
      nodeId);

                        if (value == 0.0f)
                        {
                                // The client has terminated the ray cast.
                                return;
                        }

                        if (value > 0.0f)
                        {
                                // Update segment bounding box.
                                maxFraction = value;
                                b2Vec2 t = p1 + maxFraction * (p2 - p1);
                                segmentAABB.lowerBound = b2Min(p1, t);
                                segmentAABB.upperBound = b2Max(p1, t);
                        }
                }
                else
                {
                        stack.Push(node->child1);
                        stack.Push(node->child2);
                }
        }
}
\end{DoxyCode}


The documentation for this class was generated from the following files\-:\begin{DoxyCompactItemize}
\item 
/\-Bing/\-File/cocos2d/cocos2d-\/iphone/cocos2d-\/iphone-\/2.\-1-\/beta4/external/\-Box2d/\-Box2\-D/\-Collision/b2\-Dynamic\-Tree.\-h\item 
/\-Bing/\-File/cocos2d/cocos2d-\/iphone/cocos2d-\/iphone-\/2.\-1-\/beta4/external/\-Box2d/\-Box2\-D/\-Collision/b2\-Dynamic\-Tree.\-cpp\end{DoxyCompactItemize}
